name: "Operation Ironclad: Desktop Release"

on:
  push:
    tags:
      - 'v*'

jobs:
  release:
    name: Build Desktop App (${{ matrix.platform }})
    timeout-minutes: 90
    permissions:
      contents: write
      attestations: write
      id-token: write
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: macos
            os: macos-latest
            artifact_glob: "packages/dashboard/src-tauri/target/release/bundle/**/*.dmg"
            tauri_args: "--target universal-apple-darwin"
          - platform: windows
            os: windows-latest
            artifact_glob: "packages/dashboard/src-tauri/target/release/bundle/**/*.msi"
            tauri_args: ""

    runs-on: ${{ matrix.os }}

    env:
      APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
      APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
      APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
      APPLE_ID: ${{ secrets.APPLE_ID }}
      APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
      APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
      APPLE_KEYCHAIN_PASSWORD: ${{ secrets.APPLE_KEYCHAIN_PASSWORD }}
      WINDOWS_CERTIFICATE: ${{ secrets.WINDOWS_CERTIFICATE }}
      WINDOWS_CERTIFICATE_PASSWORD: ${{ secrets.WINDOWS_CERTIFICATE_PASSWORD }}
      WINDOWS_SIGNING_TIMESTAMP_URL: ${{ secrets.WINDOWS_SIGNING_TIMESTAMP_URL }}
      CHECKSUM_SIGNING_PRIVATE_KEY: ${{ secrets.CHECKSUM_SIGNING_PRIVATE_KEY }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Check required network endpoints
        run: ./scripts/check-network-prereqs.sh

      - name: Install Protoc
        uses: arduino/setup-protoc@v3
        with:
          repo-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Rust Toolchain
        uses: actions-rust-lang/setup-rust-toolchain@v1
        with:
          targets: ${{ matrix.platform == 'windows' && 'x86_64-pc-windows-msvc' || '' }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'

      - name: Cache Rust Dependencies
        uses: actions/cache@v3
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target/
          key: ${{ runner.os }}-cargo-desktop-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-desktop-
            ${{ runner.os }}-cargo-

      - name: Cache Node Modules
        uses: actions/cache@v3
        with:
          path: |
            node_modules
            */*/node_modules
            packages/*/node_modules
            services/*/node_modules
          key: ${{ runner.os }}-pnpm-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-

      - name: Install Dependencies (macOS)
        if: matrix.platform == 'macos'
        run: |
          rustup target add aarch64-apple-darwin
          rustup target add x86_64-apple-darwin

      - name: Enable Corepack
        run: corepack enable

      - name: Install npm Dependencies
        run: pnpm install --frozen-lockfile

      - name: Run environment checks
        run: pnpm doctor

      - name: "ðŸ›¡ï¸ Operation Ironclad: Comprehensive Release Checklist"
        run: |
          chmod +x ./scripts/release-checklist.sh
          ./scripts/release-checklist.sh

      - name: Enforce signing and notarization secrets (macOS)
        if: matrix.platform == 'macos'
        shell: bash
        run: |
          required=(APPLE_CERTIFICATE APPLE_CERTIFICATE_PASSWORD APPLE_SIGNING_IDENTITY APPLE_ID APPLE_PASSWORD APPLE_TEAM_ID CHECKSUM_SIGNING_PRIVATE_KEY)
          for key in "${required[@]}"; do
            if [ -z "${!key}" ]; then
              echo "âŒ Missing required secret: $key"
              exit 1
            fi
          done

      - name: Configure macOS signing keychain + identity
        if: matrix.platform == 'macos'
        shell: bash
        run: |
          set -euo pipefail
          CERT_PATH="$RUNNER_TEMP/apple-signing.p12"
          KEYCHAIN_PATH="$RUNNER_TEMP/aethercore-signing.keychain-db"

          echo "$APPLE_CERTIFICATE" | base64 --decode > "$CERT_PATH"

          KEYCHAIN_PASSWORD="${APPLE_KEYCHAIN_PASSWORD:-$GITHUB_RUN_ID-$GITHUB_RUN_ATTEMPT-aethercore}"
          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security import "$CERT_PATH" -k "$KEYCHAIN_PATH" -P "$APPLE_CERTIFICATE_PASSWORD" -T /usr/bin/codesign -T /usr/bin/security
          security set-key-partition-list -S apple-tool:,apple: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security list-keychains -d user -s "$KEYCHAIN_PATH"

          security find-identity -v -p codesigning "$KEYCHAIN_PATH"
          security find-identity -v -p codesigning "$KEYCHAIN_PATH" | grep -F "$APPLE_SIGNING_IDENTITY"

      - name: Enforce signing secrets (Windows)
        if: matrix.platform == 'windows'
        shell: pwsh
        run: |
          $required = @('WINDOWS_CERTIFICATE', 'WINDOWS_CERTIFICATE_PASSWORD', 'CHECKSUM_SIGNING_PRIVATE_KEY', 'WINDOWS_SIGNING_TIMESTAMP_URL')
          foreach ($key in $required) {
            $value = (Get-Item -Path "Env:$key" -ErrorAction SilentlyContinue).Value
            if ([string]::IsNullOrWhiteSpace($value)) {
              throw "Missing required secret: $key"
            }
          }

      - name: Configure Windows Authenticode certificate store
        if: matrix.platform == 'windows'
        shell: pwsh
        run: |
          $certPath = Join-Path $env:RUNNER_TEMP 'aethercore-signing.pfx'
          [System.IO.File]::WriteAllBytes($certPath, [System.Convert]::FromBase64String($env:WINDOWS_CERTIFICATE))

          $securePassword = ConvertTo-SecureString -String $env:WINDOWS_CERTIFICATE_PASSWORD -AsPlainText -Force
          $imported = Import-PfxCertificate -FilePath $certPath -Password $securePassword -CertStoreLocation Cert:\CurrentUser\My -Exportable
          if (-not $imported) { throw 'Failed to import Windows signing certificate into CurrentUser\My' }

          $thumbprint = $imported.Thumbprint
          if ([string]::IsNullOrWhiteSpace($thumbprint)) { throw 'Unable to resolve imported certificate thumbprint' }

          Add-Content -Path $env:GITHUB_ENV -Value "WINDOWS_CERTIFICATE_THUMBPRINT=$thumbprint"
          Write-Host "Configured Authenticode signing certificate thumbprint: $thumbprint"

      - name: Build Frontend (TypeScript)
        run: |
          cd packages/dashboard
          pnpm run build

      - name: Build & Package Tauri App
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          projectPath: "./packages/dashboard"
          tagName: ${{ github.ref_name }}
          releaseName: "AetherCore Tactical Glass ${{ github.ref_name }}"
          releaseBody: |
            ## AetherCore Tactical Glass Release ${{ github.ref_name }}

            ### Desktop Applications
            - **Windows**: Authenticode signed installer + trusted RFC3161 timestamp
            - **macOS**: Developer ID signed, notarized, and stapled universal DMG

            ### Security Notes
            - Release checksums are cryptographically signed
            - SBOM and provenance attestations are attached to every release

            ### Installation
            See [INSTALLATION.md](https://github.com/FourMIK/AetherCore/blob/main/INSTALLATION.md).
          releaseDraft: true
          prerelease: false
          args: ${{ matrix.tauri_args }}

      - name: Upload installer bundle for clean-runner certification
        uses: actions/upload-artifact@v4
        with:
          name: desktop-installer-${{ matrix.platform }}
          path: |
            packages/dashboard/src-tauri/target/release/bundle/**/*.dmg
            packages/dashboard/src-tauri/target/release/bundle/**/*.msi
          if-no-files-found: error
          retention-days: 14

      - name: "Gate: verify macOS code signing + notarization + stapling"
        if: matrix.platform == 'macos'
        shell: bash
        run: |
          set -euo pipefail
          dmg="$(find packages/dashboard/src-tauri/target/release/bundle -name '*.dmg' | head -n 1)"
          app="$(find packages/dashboard/src-tauri/target/release/bundle -name '*.app' | head -n 1)"

          test -n "$dmg" && test -n "$app"

          codesign --verify --deep --strict --verbose=4 "$app"
          spctl --assess --type execute --verbose=4 "$app"
          xcrun stapler validate "$dmg"

      - name: "Gate: verify Windows Authenticode + trusted timestamp"
        if: matrix.platform == 'windows'
        shell: pwsh
        run: |
          $msi = Get-ChildItem -Path "packages/dashboard/src-tauri/target/release/bundle" -Recurse -Filter *.msi | Select-Object -First 1
          if (-not $msi) { throw "No MSI artifact found" }

          $signtool = Get-ChildItem "${env:ProgramFiles(x86)}\Windows Kits\10\bin" -Recurse -Filter signtool.exe |
            Sort-Object FullName -Descending |
            Select-Object -First 1
          if (-not $signtool) { throw "signtool.exe not found" }

          & $signtool.FullName verify /pa /tw /v $msi.FullName
          if ($LASTEXITCODE -ne 0) { throw "Authenticode or timestamp verification failed" }

      - name: "Validation Gate: install + launch + bootstrap ready (macOS)"
        if: matrix.platform == 'macos'
        shell: bash
        run: |
          set -euo pipefail
          dmg="$(find packages/dashboard/src-tauri/target/release/bundle -name '*.dmg' | head -n 1)"
          mount_dir="$(mktemp -d)"
          hdiutil attach "$dmg" -mountpoint "$mount_dir"
          app_path="$(find "$mount_dir" -maxdepth 1 -name '*.app' | head -n 1)"
          cp -R "$app_path" /Applications/
          hdiutil detach "$mount_dir"

          APP_BIN="/Applications/$(basename "$app_path")/Contents/MacOS/$(basename "$app_path" .app)"
          AETHERCORE_SKIP_SENTINEL_FOR_CI=1 CI=1 "$APP_BIN" --bootstrap > /tmp/aethercore-macos-launch.log 2>&1 &
          APP_PID=$!
          sleep 25
          kill "$APP_PID" || true

          CONFIG_FILE="$HOME/Library/Application Support/com.aethercore.tactical-glass-dev/runtime-config.json"
          test -f "$CONFIG_FILE"

      - name: "Validation Gate: install + launch + bootstrap ready (Windows)"
        if: matrix.platform == 'windows'
        shell: pwsh
        run: |
          $msi = Get-ChildItem -Path "packages/dashboard/src-tauri/target/release/bundle" -Recurse -Filter *.msi | Select-Object -First 1
          if (-not $msi) { throw "No MSI artifact found" }

          Start-Process msiexec.exe -ArgumentList "/i `"$($msi.FullName)`" /qn /norestart" -Wait -NoNewWindow

          $exe = Get-ChildItem -Path "$env:LOCALAPPDATA\Programs" -Recurse -Filter "*.exe" |
            Where-Object { $_.Name -like "*Tactical*" -or $_.Name -like "*aethercore*" } |
            Select-Object -First 1
          if (-not $exe) { throw "Installed executable not found" }

          $launch = Start-Process -FilePath $exe.FullName -ArgumentList "--bootstrap" -PassThru -Environment @{
            CI = '1'
            AETHERCORE_SKIP_SENTINEL_FOR_CI = '1'
          }
          Start-Sleep -Seconds 25
          if (-not $launch.HasExited) { Stop-Process -Id $launch.Id -Force }

          $configPath = Join-Path $env:APPDATA "com.aethercore.tactical-glass-dev\runtime-config.json"
          if (-not (Test-Path $configPath)) {
            throw "Bootstrap ready-state config not found at $configPath"
          }

      - name: Build checksum + signature + provenance bundle
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p release-artifacts

          checksum_file="release-artifacts/SHA256SUMS-${{ matrix.platform }}.txt"
          signature_file="${checksum_file}.sig"

          while IFS= read -r -d '' file; do
            shasum -a 256 "$file" >> "$checksum_file"
          done < <(find packages/dashboard/src-tauri/target/release/bundle -type f \( -name '*.dmg' -o -name '*.msi' -o -name '*.app' -o -name '*.exe' \) -print0)

          printf '%s' "$CHECKSUM_SIGNING_PRIVATE_KEY" > release-artifacts/checksum-signing.pem
          openssl dgst -sha256 -sign release-artifacts/checksum-signing.pem -out "$signature_file" "$checksum_file"

          cat > "release-artifacts/provenance-${{ matrix.platform }}.json" <<EOF
          {
            "tag": "${{ github.ref_name }}",
            "platform": "${{ matrix.platform }}",
            "commit": "${{ github.sha }}",
            "workflow": "${{ github.workflow }}",
            "run_id": "${{ github.run_id }}",
            "signed_checksums": "$(basename "$signature_file")"
          }
          EOF

      - name: Build release manifest from CI artifacts
        shell: bash
        run: |
          set -euo pipefail

          tauri_version="$(awk -F'"' '/^tauri = /{print $2; exit}' packages/dashboard/src-tauri/Cargo.toml)"
          rust_version="$(rustc --version | awk '{print $2}')"
          node_version="$(node --version | sed 's/^v//')"

          python3 ./scripts/build-release-manifest.py \
            --bundle-dir packages/dashboard/src-tauri/target/release/bundle \
            --output-dir release-artifacts \
            --tag "${{ github.ref_name }}" \
            --commit "${{ github.sha }}" \
            --tauri-version "${tauri_version:-2.x}" \
            --rust-version "$rust_version" \
            --node-version "$node_version" \
            --private-key-path release-artifacts/checksum-signing.pem

      - name: Upload signed checksum + provenance artifacts
        uses: actions/upload-artifact@v4
        with:
          name: release-integrity-${{ matrix.platform }}
          path: |
            release-artifacts/SHA256SUMS-${{ matrix.platform }}.txt
            release-artifacts/SHA256SUMS-${{ matrix.platform }}.txt.sig
            release-artifacts/provenance-${{ matrix.platform }}.json
            release-artifacts/release-manifest.json
            release-artifacts/release-manifest.json.sig
          if-no-files-found: error
          retention-days: 90

      - name: Generate build provenance attestation
        uses: actions/attest-build-provenance@v1
        with:
          subject-path: ${{ matrix.artifact_glob }}


      - name: Cleanup release signing key material
        if: always()
        shell: bash
        run: rm -f release-artifacts/checksum-signing.pem



  finalize-release:
    name: Finalize Desktop Release (hard gate)
    if: startsWith(github.ref, 'refs/tags/')
    needs: [release, certification-suite]
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Download integrity artifacts from matrix builds
        uses: actions/download-artifact@v4
        with:
          pattern: release-integrity-*
          path: release-assets
          merge-multiple: true

      - name: Attach integrity + provenance assets to GitHub Release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          gh release upload "${{ github.ref_name }}" \
            release-assets/SHA256SUMS-macos.txt \
            release-assets/SHA256SUMS-macos.txt.sig \
            release-assets/SHA256SUMS-windows.txt \
            release-assets/SHA256SUMS-windows.txt.sig \
            release-assets/provenance-macos.json \
            release-assets/provenance-windows.json \
            release-assets/release-manifest.json \
            release-assets/release-manifest.json.sig \
            --clobber

      - name: Publish draft release only after all signing/notarization gates pass
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh release edit "${{ github.ref_name }}" --draft=false

      - name: Confirm published integrity assets
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          gh release view "${{ github.ref_name }}" --json assets --jq '.assets[].name' | \
            grep -E 'SHA256SUMS-(macos|windows)\.txt(\.sig)?|provenance-(macos|windows)\.json|release-manifest\.json(\.sig)?'

  certification-suite:
    name: Installer Certification (${{ matrix.platform }})
    if: startsWith(github.ref, 'refs/tags/')
    needs: release
    runs-on: ${{ matrix.os }}
    timeout-minutes: 45
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: macos
            os: macos-latest
          - platform: windows
            os: windows-latest
    steps:
      - name: Download installer from release build artifacts
        uses: actions/download-artifact@v4
        with:
          name: desktop-installer-${{ matrix.platform }}
          path: certification-input

      - name: Run post-install smoke certification (macOS)
        if: matrix.platform == 'macos'
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p certification-artifacts

          cert_json="certification-artifacts/certification-result.json"
          log_file="certification-artifacts/app-launch.log"
          screenshot="certification-artifacts/failure-screenshot.png"

          check_failed() {
            local check_name="$1"
            local message="$2"
            screencapture -x "$screenshot" || true
            cat > "$cert_json" <<EOF
          {
            "platform": "macos",
            "slo_target": ">=95% successful first-run bootstrap on clean supported OS images",
            "status": "failed",
            "failed_check": "$check_name",
            "message": "$message"
          }
          EOF
            exit 1
          }

          dmg="$(find certification-input -name '*.dmg' | head -n 1)"
          [[ -n "$dmg" ]] || check_failed "artifact" "No DMG found in certification input"

          mount_dir="$(mktemp -d)"
          hdiutil attach "$dmg" -mountpoint "$mount_dir"
          app_path="$(find "$mount_dir" -maxdepth 1 -name '*.app' | head -n 1)"
          [[ -n "$app_path" ]] || check_failed "install" "No .app found inside mounted DMG"
          cp -R "$app_path" /Applications/
          hdiutil detach "$mount_dir"

          app_name="$(basename "$app_path")"
          app_bin="/Applications/${app_name}/Contents/MacOS/$(basename "$app_path" .app)"
          smoke_workdir="$RUNNER_TEMP/aethercore-smoke"
          mkdir -p "$smoke_workdir"

          (
            cd "$smoke_workdir"
            CI=1 AETHERCORE_SKIP_SENTINEL_FOR_CI=1 "$app_bin" --bootstrap > "$GITHUB_WORKSPACE/$log_file" 2>&1 &
            app_pid=$!

            bootstrap_state="$HOME/Library/Application Support/com.aethercore.tactical-glass-dev/bootstrap-state.json"
            runtime_config="$HOME/Library/Application Support/com.aethercore.tactical-glass-dev/runtime-config.json"
            sample_node_config="$smoke_workdir/data/first-node/first-node_config.json"

            deadline=$((SECONDS + 150))
            while [ $SECONDS -lt $deadline ]; do
              if [ -f "$bootstrap_state" ] && [ -f "$runtime_config" ] && [ -f "$sample_node_config" ]; then
                break
              fi
              sleep 3
            done

            if [ -f "$bootstrap_state" ] && [ -f "$runtime_config" ] && [ -f "$sample_node_config" ]; then
              kill "$app_pid" || true
              wait "$app_pid" || true
            else
              kill "$app_pid" || true
              wait "$app_pid" || true
              check_failed "smoke-flow" "Missing bootstrap/runtime/sample-node artifacts after launch"
            fi
          )

          python3 - <<'PY'
          import json
          from pathlib import Path

          bootstrap = Path.home() / 'Library/Application Support/com.aethercore.tactical-glass-dev/bootstrap-state.json'
          completed = False
          if bootstrap.exists():
              try:
                  completed = bool(json.loads(bootstrap.read_text()).get('completed'))
              except Exception:
                  completed = False

          result = {
              'platform': 'macos',
              'slo_target': '>=95% successful first-run bootstrap on clean supported OS images',
              'status': 'passed' if completed else 'failed',
              'checks': [
                  {'name': 'launch app', 'status': 'passed'},
                  {'name': 'bootstrap stack', 'status': 'passed'},
                  {'name': 'deploy sample node', 'status': 'passed'},
                  {'name': 'verify dashboard state', 'status': 'passed' if completed else 'failed'}
              ]
          }
          Path('certification-artifacts/certification-result.json').write_text(json.dumps(result, indent=2))
          if not completed:
              raise SystemExit('bootstrap-state.json exists but completed != true')
          PY

      - name: Run post-install smoke certification (Windows)
        if: matrix.platform == 'windows'
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force -Path certification-artifacts | Out-Null

          $certJson = "certification-artifacts/certification-result.json"
          $logFile = "certification-artifacts/app-launch.log"
          $screenshot = "certification-artifacts/failure-screenshot.png"

          function Save-Failure {
            param(
              [string]$Check,
              [string]$Message
            )

            try {
              Add-Type -AssemblyName System.Windows.Forms
              Add-Type -AssemblyName System.Drawing
              $bounds = [System.Windows.Forms.Screen]::PrimaryScreen.Bounds
              $bitmap = New-Object System.Drawing.Bitmap $bounds.Width, $bounds.Height
              $graphics = [System.Drawing.Graphics]::FromImage($bitmap)
              $graphics.CopyFromScreen($bounds.Location, [System.Drawing.Point]::Empty, $bounds.Size)
              $bitmap.Save((Join-Path $PWD $screenshot), [System.Drawing.Imaging.ImageFormat]::Png)
              $graphics.Dispose()
              $bitmap.Dispose()
            } catch {
              Write-Host "Screenshot capture unavailable: $($_.Exception.Message)"
            }

            @{ 
              platform = 'windows';
              slo_target = '>=95% successful first-run bootstrap on clean supported OS images';
              status = 'failed';
              failed_check = $Check;
              message = $Message
            } | ConvertTo-Json -Depth 8 | Set-Content -Path $certJson -Encoding UTF8

            throw "[$Check] $Message"
          }

          $msi = Get-ChildItem -Path certification-input -Recurse -Filter *.msi | Select-Object -First 1
          if (-not $msi) { Save-Failure -Check 'artifact' -Message 'No MSI found in certification input' }

          Start-Process msiexec.exe -ArgumentList "/i `"$($msi.FullName)`" /qn /norestart" -Wait -NoNewWindow

          $exe = Get-ChildItem -Path "$env:LOCALAPPDATA\Programs" -Recurse -Filter '*.exe' |
            Where-Object { $_.Name -like '*Tactical*' -or $_.Name -like '*aethercore*' } |
            Select-Object -First 1
          if (-not $exe) { Save-Failure -Check 'install' -Message 'Installed executable not found' }

          $smokeDir = Join-Path $env:RUNNER_TEMP 'aethercore-smoke'
          New-Item -ItemType Directory -Force -Path $smokeDir | Out-Null

          Push-Location $smokeDir
          try {
            $launch = Start-Process -FilePath $exe.FullName -ArgumentList '--bootstrap' -RedirectStandardOutput (Join-Path $env:GITHUB_WORKSPACE $logFile) -RedirectStandardError (Join-Path $env:GITHUB_WORKSPACE $logFile) -PassThru -Environment @{
              CI = '1'
              AETHERCORE_SKIP_SENTINEL_FOR_CI = '1'
            }

            $bootstrapState = Join-Path $env:APPDATA 'com.aethercore.tactical-glass-dev\bootstrap-state.json'
            $runtimeConfig = Join-Path $env:APPDATA 'com.aethercore.tactical-glass-dev\runtime-config.json'
            $sampleNodeConfig = Join-Path $smokeDir 'data\first-node\first-node_config.json'

            $deadline = (Get-Date).AddSeconds(150)
            while ((Get-Date) -lt $deadline) {
              if ((Test-Path $bootstrapState) -and (Test-Path $runtimeConfig) -and (Test-Path $sampleNodeConfig)) {
                break
              }
              Start-Sleep -Seconds 3
            }

            if (-not (Test-Path $bootstrapState) -or -not (Test-Path $runtimeConfig) -or -not (Test-Path $sampleNodeConfig)) {
              if (-not $launch.HasExited) { Stop-Process -Id $launch.Id -Force }
              Save-Failure -Check 'smoke-flow' -Message 'Missing bootstrap/runtime/sample-node artifacts after launch'
            }

            $bootstrap = Get-Content -Raw -Path $bootstrapState | ConvertFrom-Json
            if (-not $bootstrap.completed) {
              if (-not $launch.HasExited) { Stop-Process -Id $launch.Id -Force }
              Save-Failure -Check 'verify-dashboard-state' -Message 'bootstrap-state.json completed != true'
            }

            if (-not $launch.HasExited) { Stop-Process -Id $launch.Id -Force }
          }
          finally {
            Pop-Location
          }

          @{
            platform = 'windows'
            slo_target = '>=95% successful first-run bootstrap on clean supported OS images'
            status = 'passed'
            checks = @(
              @{ name = 'launch app'; status = 'passed' },
              @{ name = 'bootstrap stack'; status = 'passed' },
              @{ name = 'deploy sample node'; status = 'passed' },
              @{ name = 'verify dashboard state'; status = 'passed' }
            )
          } | ConvertTo-Json -Depth 8 | Set-Content -Path $certJson -Encoding UTF8

      - name: Upload certification diagnostics
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: installer-certification-${{ matrix.platform }}
          path: certification-artifacts
          if-no-files-found: warn
          retention-days: 90
